#include <stdlib.h>
#include <string.h>
#include <fts.h>
#include <fnmatch.h>
#include <unistd.h>
#include <ruby.h>

/* cmdline sf [options] path [path]
 * options:
 *   -s 'skip' -- skip files / directories match 'skip'
 */

static char **dir_ignores = NULL;
static size_t dir_igsize = 0;
static char **ignores = NULL;
static size_t igsize = 0;

static int match_fnignores(const char *name, char **igs, size_t igsz) {
    //printf("name: '%s'\n", name);
    for (size_t i = 0; i < igsz; ++i) {
        if (fnmatch(igs[i], name, FNM_PATHNAME) == 0) {
            //printf("matched %s\n", igs[i]);
            return 1;
        }
    }
    return 0;
}

static int match_ignores(FTSENT *node) {
    if (node->fts_info & FTS_D) {
        return match_fnignores(node->fts_name, dir_ignores, dir_igsize);
    } else {
        return match_fnignores(node->fts_name, ignores, igsize);
    }
}

static FILE *try_file(const char *fname) {
    FILE *fp = fopen(fname, "w");
    if (fp == NULL) {
        perror("fopen: ");
        exit(1);
    }
    return fp;
}

int main(int argc, char *argv[])
{
    FILE *out = stdout;
    int ch = 0;
    while ( (ch = getopt(argc, argv, "s:d:o:")) != -1) {
        switch (ch) {
            case 's':
                ignores = (char **) realloc(ignores, sizeof(const char *) * (++igsize));
                ignores[igsize-1] = strdup(optarg);
                break;
            case 'd':
                dir_ignores = (char **) realloc(dir_ignores, sizeof(const char *) * (++dir_igsize));
                dir_ignores[dir_igsize-1] = strdup(optarg);
                break;
            case 'o':
                out = try_file(optarg);
                break;
        }
    }

    //printf("ignores: %zd\ndir_ignores: %zd\n", igsize, dir_igsize);

    int rem = argc - optind;
    char *dot[] =  { ".", 0 };
    char **argp = argv + optind;
    char **paths = NULL;

    if (rem > 0) {
        paths = argp;
    } else {
        paths = dot;
    }

    FTS *tree = fts_open(paths, FTS_NOCHDIR, 0);
    if (!tree) {
        perror("fts_open");
        return 1;
    }

    FTSENT *node = NULL;
    while ( (node = fts_read(tree)) != NULL) {
        if (match_ignores(node)) {
            fts_set(tree, node, FTS_SKIP);
        } else if (node->fts_info & FTS_F) {
            fprintf(out, "%s\n", node->fts_accpath);
        }
    }

    fts_close(tree);

    if (out != stdout) {
        fflush(out);
        fclose(out);
    }

    return 0;
}
